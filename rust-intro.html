<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>Rust</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="template/css/reveal.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="template/css/theme/white.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'template/css/print/pdf.css' : 'template/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="template/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
  <h1 class="title">Rust</h1>
  <p class="subtitle">A comprehensive introduction</p>
</section>

<section><section id="whoami1" class="titleslide slide level1"><h1><code>whoami(1)</code></h1></section><section class="slide level2">

<p>Katharina Fey ( <code>@spacekookie</code> )</p>
<ul>
<li>Software Engineer from Berlin</li>
<li>Works with Rust at Ferrous Systems</li>
</ul>
</section><section class="slide level2">

<ul>
<li>Member of Community Team and <code>cli-wg</code></li>
<li>Creating a <code>database-wg</code></li>
<li>Developing and maintaining Rust tools</li>
<li>Giving workshops and organising meetups</li>
<li>https://berline.rs</li>
</ul>
</section><section class="slide level2">

<p>If you have questions beyond this workshop:</p>
<ul>
<li>E-Mail: kookie@spacekookie.de</li>
<li>GPG: <code>555F 2E4B 6F87 F91A 4110</code></li>
<li>XMPP: <code>kookie@spacekookie.de</code></li>
<li>Twitter: <code>@spacekookie</code></li>
</ul>
</section></section>
<section><section id="what-is-rust" class="titleslide slide level1"><h1>What is Rust?</h1></section><section class="slide level2">

<ul>
<li>Originally {developed, funded} by Mozilla</li>
<li>Replacement for <code>C++</code> in Firefox</li>
<li>Replace individual components gradually</li>
<li>Fundamentally built around good FFI</li>
<li>Developed by a large community world-wide</li>
</ul>
</section><section class="slide level2">

<p>(We won't cover FFI today)</p>
</section><section class="slide level2">

<ul>
<li>Influences from C++ and Haskell</li>
</ul>
</section><section id="spectrum-of-programming-languages" class="slide level2">
<h2>Spectrum of Programming languages</h2>
<figure>
<img src="images/purity.png" alt="Rust doesn&#39;t really fit in this spectrum" /><figcaption>Rust doesn't really fit in this spectrum</figcaption>
</figure>
</section><section id="some-highlights" class="slide level2">
<h2>Some highlights</h2>
<ul>
<li>Memory safety without GC</li>
<li>Thread safety without Runtime</li>
<li>&quot;Zero cost abstractions&quot;</li>
<li>Utilises static analysis heavily</li>
</ul>
</section><section class="slide level2">

<blockquote>
<p>Rust is a rather German programming language:</p>
<p>It's very precise and has no sense of humour</p>
</blockquote>
</section></section>
<section><section id="installation" class="titleslide slide level1"><h1>Installation</h1></section><section class="slide level2">

<ul>
<li>https://rustup.rs</li>
</ul>
<p>Use whatever editor you're comfy with</p>
</section><section id="test-setup" class="slide level2">
<h2>Test setup</h2>
<ul>
<li>Type <code>&quot;cargo new &lt;name&gt;&quot;</code></li>
<li>Folder should contain <code>Cargo.toml</code> and <code>src/main.rs</code></li>
<li>Running <code>&quot;cargo run&quot;</code> should print &quot;Hello world!&quot;</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() <span class="op">{</span>
    <span class="pp">println!</span>(<span class="st">&quot;Hello world&quot;</span>);
<span class="op">}</span></code></pre></div>
</section><section id="debug-printing" class="slide level2">
<h2>Debug printing</h2>
<ul>
<li><code>&quot;println!&quot;</code> is a macro (marked by &quot;!&quot;)</li>
<li><code>&quot;{}&quot;</code> is used for string interpolation</li>
<li>Different formatters can be used:
<ul>
<li><code>&quot;{:?}&quot;</code> debug format</li>
<li><code>&quot;{:#?}&quot;</code> pretty debug format</li>
<li><code>&quot;{:X}&quot;</code> upper-case hexadecimal numbers</li>
<li>... many more in the docs!</li>
</ul></li>
</ul>
</section><section class="slide level2">

<p>https://play.rust-lang.org</p>
</section></section>
<section><section id="slides" class="titleslide slide level1"><h1>Slides</h1></section><section class="slide level2">

<ul>
<li>https://github.com/spacekookie/one-day-rust</li>
<li>Contains some example code too</li>
<li>PRs welcome!</li>
</ul>
</section></section>
<section><section id="basics" class="titleslide slide level1"><h1>Basics</h1></section><section id="theres-no-null" class="slide level2">
<h2>There's no null</h2>
</section><section id="section" class="slide level2">
<h2>üéâ</h2>
</section><section id="basic-types" class="slide level2">
<h2>Basic Types</h2>
<ul>
<li>Primitives</li>
<li><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code></li>
<li><code>i8</code>, <code>i16</code>, ...</li>
<li><code>f32</code>, <code>f64</code>, ...</li>
<li><code>bool</code>, <code>char</code>, <code>usize</code>, <code>isize</code></li>
<li>Tuples i.e. <code>(5, false, 'c')</code></li>
<li><code>()</code> = Unit/ void</li>
</ul>
</section><section id="slices" class="slide level2">
<h2>Slices ü•ß</h2>
<ul>
<li>i.e. <code>[1, 2, 3, 4]</code></li>
<li>Essentially arrays</li>
<li>Exist on Stack or Heap</li>
<li>Don't grow or shrink</li>
</ul>
</section><section id="strings" class="slide level2">
<h2>Strings</h2>
<ul>
<li><code>String</code> vs <code>&amp;str</code></li>
<li>Heap allocated/ growable vs char-array</li>
<li>Both <code>utf-8</code> enforcing!</li>
<li>Turn one into the other</li>
<li><code>to_string()</code></li>
<li><code>into()</code></li>
</ul>
</section><section id="libstd-types" class="slide level2">
<h2>libstd types</h2>
<ul>
<li><code>Vec</code> a growable vector</li>
<li><code>HashMap</code>, <code>HashSet</code>, <code>VecDeque</code>, ...</li>
</ul>
</section><section id="functions" class="slide level2">
<h2>Functions</h2>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> square(x: <span class="dt">i32</span>) -&gt; <span class="dt">i64</span> <span class="op">{</span>
    x * x
<span class="op">}</span></code></pre></div>
<ul>
<li>Last line without a <code>;</code> implicitly returns</li>
<li><code>return</code> keyword still exists for ambigous cases</li>
</ul>
</section><section id="mutability" class="slide level2">
<h2>Mutability</h2>
<ul>
<li>Variable bindings are by default immutable</li>
<li><code>mut</code> keyword exists</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
<span class="co">// x = 6; // this will fail!</span>

<span class="kw">let</span> <span class="kw">mut</span> y = <span class="dv">5</span>;
y = <span class="dv">6</span>; <span class="co">// this is fine!</span></code></pre></div>
<ul>
<li>Lints against useless <code>mut</code></li>
</ul>
</section><section id="enums" class="slide level2">
<h2>Enums</h2>
<ul>
<li>Similar to algebraic data types in Haskell</li>
<li>Variants not first-class types (yet!)</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Action <span class="op">{</span>
  Nothing,
  Move <span class="op">{</span> x: <span class="dt">i64</span>, y: <span class="dt">i64</span> <span class="op">}</span>, <span class="co">// Structure enum</span>
  Attack(Unit),            <span class="co">// Tuple enum</span>
<span class="op">}</span></code></pre></div>
</section><section class="slide level2">

<p>Use pattern-matching to distinguish variants</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> act <span class="op">{</span>
  Nothing =&gt; <span class="pp">println!</span>(<span class="st">&quot;Nice day to just look around&quot;</span>),
  Move <span class="op">{</span> x, y <span class="op">}</span> =&gt; move_to(x, y),
  Attack(trg) =&gt; attack(trg),
<span class="op">}</span></code></pre></div>
</section></section>
<section><section id="speaking-of-enums" class="titleslide slide level1"><h1>Speaking of enums</h1></section><section id="option-result" class="slide level2">
<h2>Option &amp; Result</h2>
<ul>
<li>Two enums provided by <code>libstd</code>/<code>libcore</code></li>
<li>Used for <em>really</em> cool error handling</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> can_fail(fails: <span class="dt">bool</span>) -&gt; <span class="dt">Option</span>&lt;&amp;<span class="dt">str</span>&gt; <span class="op">{</span>
    <span class="kw">if</span> !fails <span class="op">{</span>
        <span class="cn">Some</span>(<span class="st">&quot;Cool&quot;</span>)
    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span>
        <span class="cn">None</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
</section><section class="slide level2">

<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> can_fail(fails: <span class="dt">bool</span>) -&gt; <span class="dt">Result</span>&lt;&amp;<span class="dt">str</span>, &amp;<span class="dt">str</span>&gt; <span class="op">{</span>
    <span class="kw">if</span> !fails <span class="op">{</span>
        <span class="cn">Ok</span>(<span class="st">&quot;Cool&quot;</span>)
    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span>
        <span class="cn">Err</span>(<span class="st">&quot;You were setting up for failure!&quot;</span>)
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
</section><section class="slide level2">

<ul>
<li><code>Option</code> represents a possible missing value.</li>
<li>Use <code>unwrap()</code> to access data</li>
<li>Panics if value doesn't exist</li>
<li><code>?</code> operator can gracefully handle errors</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="cn">Some</span>(<span class="st">&quot;Cool&quot;</span>);
<span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, x.expect(<span class="st">&quot;Value missing!&quot;</span>));</code></pre></div>
</section><section class="slide level2">

<p>You can also use pattern matchin to access data</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = can_fail(<span class="cn">false</span>);
<span class="kw">match</span> x <span class="op">{</span>
    <span class="cn">Some</span>(val) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, val),
    <span class="cn">None</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;&lt;missing&gt;&quot;</span>),
<span class="op">}</span></code></pre></div>
</section><section class="slide level2">

<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> do_stuff() -&gt; <span class="dt">Result</span>&lt;(), MyError&gt; <span class="op">{</span>
    <span class="kw">let</span> x = can_fail()?;
    
    <span class="co">// ... is the same as ...</span>

    <span class="kw">let</span> y = <span class="kw">match</span> can_fail() <span class="op">{</span>
        <span class="cn">Ok</span>(y) =&gt; y,
        <span class="cn">Err</span>(e) =&gt; <span class="kw">return</span> <span class="cn">Err</span>(e),
    <span class="op">}</span>;
<span class="op">}</span></code></pre></div>
</section></section>
<section><section id="example-time" class="titleslide slide level1"><h1>Example Time!</h1></section><section class="slide level2">

<ul>
<li>Get comfortable writing Rust</li>
<li>Use stuff covered so far</li>
</ul>
</section><section id="write-a-small-parser" class="slide level2">
<h2>Write a small parser</h2>
<ul>
<li>Protocol to publish and retrieve</li>
<li><code>PUB &lt;item&gt;, &lt;item&gt;</code></li>
<li><code>GET &lt;number&gt;</code></li>
<li>Parse String into Enum</li>
<li>Handle parse errors</li>
</ul>
</section><section class="slide level2">

<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Command <span class="op">{</span>
    Pub(<span class="dt">Vec</span>&lt;<span class="dt">String</span>&gt;),
    Get(<span class="dt">u32</span>),
<span class="op">}</span>

<span class="kw">enum</span> ParseError <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>

<span class="kw">fn</span> parse(input: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Result</span>&lt;Command, ParseError&gt; <span class="op">{}</span></code></pre></div>
</section></section>
<section><section id="structures-oo" class="titleslide slide level1"><h1>Structures &amp; OO</h1></section><section class="slide level2">

<ul>
<li>Rust has some features that might look like object-orientation</li>
<li>Rust is OO, depending on who you ask</li>
<li>Depends on if this person likes OO or not</li>
</ul>
</section><section id="rust-doesnt-have" class="slide level2">
<h2>Rust <em>doesn't</em> have</h2>
<ul>
<li>Inheritance</li>
<li>Polymorphism</li>
<li>Runtime generics</li>
</ul>
</section><section id="rust-does-have" class="slide level2">
<h2>Rust <em>does</em> have</h2>
<ul>
<li>Monomorphic generics</li>
<li>Interfaces (via &quot;Traits&quot;)</li>
<li>Trait inheritance (usually called &quot;trait bounds&quot;)</li>
<li>Associative functions</li>
</ul>
</section><section id="is-rust-object-oriented" class="slide level2">
<h2>Is Rust object-oriented?</h2>
</section><section id="section-1" class="slide level2">
<h2>ü§∑</h2>
</section><section id="structs" class="slide level2">
<h2><code>structs</code></h2>
<ul>
<li>Analogue to a <code>struct</code> in C or C++</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> MyType <span class="op">{</span>
  num: <span class="dt">u32</span>,
  name: <span class="dt">String</span>,
<span class="op">}</span></code></pre></div>
</section><section class="slide level2">

<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> GenericStruct&lt;T&gt; <span class="op">{</span>
    thing: T
<span class="op">}</span></code></pre></div>
</section><section id="associative-functions" class="slide level2">
<h2>Associative functions</h2>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> MyType;

<span class="kw">impl</span> MyType <span class="op">{</span>
    <span class="kw">fn</span> new() -&gt; <span class="kw">Self</span> <span class="op">{</span>
        <span class="kw">Self</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="kw">fn</span> main() <span class="op">{</span>
    <span class="kw">let</span> t = MyType::new();
<span class="op">}</span></code></pre></div>
</section><section id="mutability-self" class="slide level2">
<h2>Mutability &amp; self</h2>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Person <span class="op">{</span> name: <span class="dt">String</span>, age: <span class="dt">u8</span> <span class="op">}</span>

<span class="kw">impl</span> Person <span class="op">{</span>
    <span class="kw">fn</span> new() -&gt; <span class="kw">Self</span> <span class="op">{</span>
        <span class="kw">Self</span> <span class="op">{</span> name: <span class="st">&quot;Katharina&quot;</span>.into(), age: <span class="dv">26</span> <span class="op">}</span>
    <span class="op">}</span>
    <span class="kw">fn</span> birthday(&amp;<span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span> <span class="kw">self</span>.age += <span class="dv">1</span>; <span class="op">}</span>    
    <span class="kw">fn</span> age(&amp;<span class="kw">self</span>) -&gt; <span class="dt">u8</span> <span class="op">{</span> <span class="kw">self</span>.age <span class="op">}</span>
<span class="op">}</span>

<span class="co">// ...</span>

<span class="kw">let</span> <span class="kw">mut</span> kat = Person::new();
kat.birthday(); <span class="co">// `&amp;mut self` is implicit</span></code></pre></div>
</section><section id="interfaces-traits" class="slide level2">
<h2>Interfaces &amp; Traits</h2>
<ul>
<li>Interface types are called &quot;Traits&quot;</li>
<li>A type can implement an arbitrary number of these</li>
<li>Some special rules (orphan rules) apply</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Printable: <span class="bu">Debug</span> <span class="op">{</span>
    <span class="kw">fn</span> print(&amp;<span class="kw">self</span>);
<span class="op">}</span></code></pre></div>
</section><section class="slide level2">

<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::ops::<span class="bu">Drop</span>;

<span class="kw">struct</span> NativeCtx(<span class="kw">const</span> *ptr);

<span class="co">// `fn drop` becomes associated with `NativeCtx`</span>
<span class="kw">impl</span> <span class="bu">Drop</span> <span class="kw">for</span> NativeCtx <span class="op">{</span>
    <span class="kw">fn</span> drop(&amp;<span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span>
        <span class="kw">unsafe</span> <span class="op">{</span>
            native_thing_close(<span class="kw">self</span>.<span class="dv">0</span>);
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
</section><section id="in-summary" class="slide level2">
<h2>In summary</h2>
<ul>
<li>Rust has some object-oriented features</li>
<li><code>fn new()</code> is constructor by convention only</li>
<li>Mutability encoded in function signatures</li>
</ul>
</section></section>
<section><section id="ownership-borrowing" class="titleslide slide level1"><h1>Ownership &amp; Borrowing</h1></section><section id="what-is-memory-safety" class="slide level2">
<h2>What is memory safety?</h2>
</section><section class="slide level2">

<ul>
<li>Use after free</li>
<li>Double free</li>
</ul>
<p>Leaking memory is fine‚Ñ¢</p>
</section><section class="slide level2">

<p>Fundamental question:</p>
<ul>
<li>&quot;Who&quot; owns data?</li>
<li>... and cleans it up?!</li>
</ul>
</section><section id="ownership" class="slide level2">
<h2>Ownership</h2>
<ul>
<li>In Rust all data has an owner</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> MyStruct;
<span class="kw">fn</span> do_something(_: MyStruct);

<span class="kw">let</span> x = MyStruct; <span class="co">// I own `x`</span>

do_something(x); <span class="co">// I give `x` away</span>

do_something(x); <span class="co">// This won&#39;t _compile_!</span></code></pre></div>
</section><section class="slide level2">

<pre><code>error[E0382]: use of moved value: `x`
 --&gt; main.rs:8:18
  |
6 |     do_something(x);
  |                  - value moved here
7 | 
8 |     do_something(x);
  |                  ^ value used here after move
  |
  = note: move occurs because `x` has type `MyStruct`, which does not implement the `Copy` trait

error: aborting due to previous error</code></pre>
</section><section class="slide level2">

<ul>
<li>Always and <em>only</em> one owner to data</li>
<li>Responsible for freeing memory</li>
</ul>
</section><section class="slide level2">

<h3 id="question-that-sucks">Question: that sucks</h3>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> does_something(data: MyStruct) -&gt; MyStruct <span class="op">{</span>
    <span class="co">// Important scientific computing</span>
    data
<span class="op">}</span></code></pre></div>
<p>(that's not a question, really)</p>
</section><section id="two-solutions" class="slide level2">
<h2>Two solutions</h2>
</section><section id="copy-clone" class="slide level2">
<h2>Copy &amp; Clone</h2>
</section><section id="two-traits-in-libcore" class="slide level2">
<h2>Two traits in libcore</h2>
<ul>
<li>Copy = <code>memcpy</code></li>
<li>Clone = Deep copy</li>
</ul>
</section><section class="slide level2">

<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> thing(_: <span class="dt">u8</span>) <span class="op">{}</span>

<span class="kw">let</span> x = <span class="dv">5</span>;
thing(x); <span class="co">// {Integer} is `Copy`</span>
thing(x); <span class="co">// This works</span></code></pre></div>
</section><section class="slide level2">

<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="at">)]</span> <span class="co">// &lt;-- Macro that provides `Clone`</span>
<span class="kw">struct</span> NotCopy <span class="op">{</span>
    name: <span class="dt">String</span>
<span class="op">}</span>

<span class="kw">fn</span> thing(_: NotCopy) <span class="op">{}</span>
<span class="kw">let</span> x: <span class="dt">String</span> = <span class="st">&quot;No Strings attached&quot;</span>;

thing(x.clone());
thing(x);</code></pre></div>
<ul>
<li><code>Clone</code> allows pre-emptive copying of data</li>
<li>In reality LLVM can optimise many of these</li>
<li><code>Clone</code> can be &quot;derived&quot; for a type if all members are also <code>Clone</code></li>
</ul>
</section><section id="borrowing" class="slide level2">
<h2>Borrowing</h2>
</section><section class="slide level2">

<ul>
<li>If you own something, you can lend it</li>
<li>Data can be shared without moving ownership!</li>
<li>Under the hood: pointers!</li>
</ul>
</section><section class="slide level2">

<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = MyStruct; <span class="co">// ÀØ Pretzel operator means &quot;borrow&quot;</span>
<span class="kw">fn</span> do_something(foo: &amp;MyStruct) <span class="op">{</span> <span class="op">}</span>

do_something(&amp;x);
do_something(&amp;x); <span class="co">// This is fine</span></code></pre></div>
</section><section class="slide level2">

<ul>
<li>Borrowing is encoded at the type-level</li>
<li><code>MyStruct</code> and <code>&amp;MyStruct</code> are fundamentally different types!</li>
</ul>
</section><section id="mutability-1" class="slide level2">
<h2>Mutability</h2>
<ul>
<li>When borrowing data, mutability is <strong>exclusive</strong></li>
<li>No two <code>&amp;mut</code> can exist for the same data twice.</li>
</ul>
</section><section id="borrowing-rules" class="slide level2">
<h2>Borrowing Rules</h2>
<p>As many read-only borrows as you want</p>
<p>OR</p>
<p>One (1) <code>&amp;mut</code> borrow</p>
</section><section id="why" class="slide level2">
<h2>why</h2>
</section><section class="slide level2">

<ul>
<li>Multiple sources of errors that can be avoided at compile time</li>
<li>Usually Ownership/ Borrowing mechanisms an be caught by patterns manually</li>
<li>By letting the compiler enforce them there is less cognitive load</li>
</ul>
</section><section id="examples" class="slide level2">
<h2>üî• Examples üî•</h2>
</section><section class="slide level2">

<p>Should this compile?</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> f = File::open(<span class="st">&quot;foo.txt)?;</span>

<span class="st">thread::spawn(|| {</span>
<span class="st">    let mut buf = vec![];</span>
<span class="st">    f.read_exact(&amp;mut buf).unwrap();</span>
<span class="st">})</span></code></pre></div>
</section><section class="slide level2">

<p>No!</p>
<pre><code>error[E0373]: closure may outlive the current function, but it borrows `f`, which is owned by the current function
  --&gt; main.rs:8:19
   |
8  |     thread::spawn(|| {
   |                   ^^ may outlive borrowed value `f`
9  |         let mut buf = vec![];
10 |         f.read_to_end(&amp;mut buf).unwrap();
   |         - `f` is borrowed here
help: to force the closure to take ownership of `f` (and any other referenced variables), use the `move` keyword
   |
8  |     thread::spawn(move || {
   |                   ^^^^^^^</code></pre>
</section><section class="slide level2">

<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> f = File::open(<span class="st">&quot;foo.txt)?;</span>

<span class="st">thread::spawn(move || {</span>
<span class="st">    let mut buf = vec![];</span>
<span class="st">    f.read_exact(&amp;mut buf).unwrap();</span>
<span class="st">})</span></code></pre></div>
</section><section class="slide level2">

<p>Should this compile?</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> f = File::open(<span class="st">&quot;foo.txt&quot;</span>)?;

<span class="kw">for</span> _ <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">3</span> <span class="op">{</span>
    thread::spawn(|| <span class="op">{</span>
        <span class="kw">let</span> <span class="kw">mut</span> buf = <span class="pp">vec!</span><span class="op">[]</span>;
        f.read_exact(&amp;<span class="kw">mut</span> buf).unwrap();
    <span class="op">}</span>);
<span class="op">}</span></code></pre></div>
</section><section class="slide level2">

<p>No (not even if we move!)</p>
<pre><code>error[E0382]: capture of moved value: `f`
  --&gt; main.rs:11:13
   |
9  |         thread::spawn(move || {
   |                       ------- value moved (into closure) here
10 |             let mut buf = vec![];
11 |             f.read_to_end(&amp;mut buf).unwrap();
   |             ^ value captured here after move
   |
   = note: move occurs because `f` has type `std::fs::File`, which does not implement `Copy` </code></pre>
</section></section>
<section><section id="the-in-the-room" class="titleslide slide level1"><h1>The üêò in the room</h1></section><section class="slide level2">

<ul>
<li>&quot;Lifetimes&quot; are mentioned in error messages</li>
<li>The lifetime of data is an explicit concept in Rust</li>
</ul>
<p>TLDR:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Wrap&lt;<span class="ot">&#39;outer</span>&gt; <span class="op">{</span>
    name: &amp;<span class="ot">&#39;outer</span> <span class="dt">str</span>
<span class="op">}</span></code></pre></div>
<p>We won't cover this it more detail here!</p>
</section></section>
<section><section id="iterators" class="titleslide slide level1"><h1>Iterators</h1></section><section id="iterator-api" class="slide level2">
<h2>Iterator API</h2>
<ul>
<li>Rust iterators are lazy</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> list: <span class="dt">Vec</span>&lt;_&gt; = (<span class="dv">0.</span>.)
    .take(<span class="dv">1024</span>)
    .map(|i| i * i)
    .collect();</code></pre></div>
</section><section class="slide level2">

<p>Infinite iterators</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::net::TcpListener;

<span class="kw">let</span> listener = <span class="co">// ...</span>
<span class="kw">for</span> stream <span class="kw">in</span> listener.incoming() <span class="op">{</span>
    <span class="co">// ... do stuff with Stream</span>
<span class="op">}</span></code></pre></div>
</section></section>
<section><section id="example-time-2" class="titleslide slide level1"><h1>Example Time 2!</h1></section><section class="slide level2">

<ul>
<li>Expand on the earlier example</li>
<li>Add an actual server to it</li>
<li>Hint: `std::net::{TcpListener, TcpStream};</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() <span class="op">{</span>
    <span class="kw">let</span> <span class="kw">mut</span> data = VecDeque::new();
    
    <span class="co">// - accept TCP connections</span>
    <span class="co">// - Read incoming data to String</span>
    <span class="co">// - Call `parse` function with String</span>
    <span class="co">// - Send back data or error</span></code></pre></div>
</section></section>
<section><section id="modules-and-crates" class="titleslide slide level1"><h1>Modules and crates üì¶</h1></section><section class="slide level2">

<ul>
<li>Programs rarely remain simple enough for one file</li>
<li>Breaking code out into multiple files is important</li>
<li>Libraries in Rust are called &quot;crates&quot;</li>
<li>https://crates.io package index</li>
</ul>
</section><section id="modules" class="slide level2">
<h2>Modules</h2>
<ul>
<li>Modules are either files or folders with a name</li>
<li>Folders need an &quot;entry&quot; file</li>
<li>Either <code>foo.rs</code> or <code>foo/mod.rs</code> can create the &quot;foo&quot; module</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> foo; <span class="co">// Load &quot;foo&quot; into compilation</span>

<span class="kw">use</span> foo::Foo; <span class="co">// include things from &quot;foo&quot; module</span></code></pre></div>
</section><section class="slide level2">

<pre><code>.
‚îú‚îÄ‚îÄ foo
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ bar.rs
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ mod.rs // Either this
‚îú‚îÄ‚îÄ foo.rs     // or this, but not both!
‚îî‚îÄ‚îÄ main.rs</code></pre>
</section><section id="crates" class="slide level2">
<h2>Crates</h2>
<ul>
<li>A binary &quot;crate&quot; starts with <code>main.rs</code></li>
<li>A library crate starts with <code>lib.rs</code></li>
</ul>
</section><section id="dependencies" class="slide level2">
<h2>Dependencies</h2>
<p>Project files written in TOML</p>
<p><small>Neither obvious nor minimal</small></p>
<pre class="toml"><code>[package]
name = &quot;badredis&quot;
version = &quot;0.1.0&quot; 
authors = [&quot;Katharina Fey &lt;kookie@spacekookie.de&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
rocket = &quot;0.4&quot;
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;</code></pre>
</section><section id="tests" class="slide level2">
<h2>Tests</h2>
<ul>
<li>Cargo has a testing framework built-in</li>
<li><code>src/tests/</code> are unit tests</li>
<li><code>tests/</code> are integration tests</li>
<li>Or mark functions with <code>&quot;#[test]&quot;</code></li>
</ul>
<pre><code> ‚ù§ (azedes) ~/P/a/parse&gt; cargo test
 Compiling parse v0.1.0 (/.../accu-workshop/parse)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running target/debug/deps/parse-21fa3580bcb761eb

running 1 test
test basic_function ... ok

test result: ok. 1 passed; 0 failed;</code></pre>
</section></section>
<section><section id="advanced-subjects" class="titleslide slide level1"><h1>Advanced subjects üêâ</h1></section><section class="slide level2">

<ul>
<li>Concurrency with &quot;Send&quot; and &quot;Sync&quot; traits</li>
<li>Async server programming</li>
<li>&quot;Unsafe&quot; sub-language</li>
<li>FFI and &quot;native&quot; calls</li>
<li>Declarative Macros</li>
<li>Procedural Macros/ Compiler attributes</li>
</ul>
</section><section id="send-sync" class="slide level2">
<h2>Send &amp; Sync</h2>
<ul>
<li>Describes if a type is thread-safe</li>
<li>Used as a marker trait</li>
<li>Implementation is empty - compiler trusts Developer</li>
<li>This is however &quot;unsafe&quot;</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> <span class="kw">impl</span> <span class="bu">Send</span> <span class="kw">for</span> MyDataStructure <span class="op">{}</span></code></pre></div>
</section><section id="async-server-programming" class="slide level2">
<h2>Async server programming</h2>
<ul>
<li>Future and Poll types in libstd/libcore</li>
<li><code>&quot;futures.rs&quot;</code> crate provides zero cost abstraction combinators</li>
<li>async/await syntax not stabilised yet, but in the final stages of implementation</li>
<li>Currently requires nightly Rust</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">//     Signature expands to `Future&lt;Item=Result&lt;String, io::Error&gt;&gt;`</span>
async <span class="kw">fn</span> things_with_io() -&gt; <span class="dt">Result</span>&lt;<span class="dt">String</span>, io::Error&gt; <span class="op">{</span> <span class="co">/* ... */</span> <span class="op">}</span>

<span class="kw">let</span> string = <span class="pp">await!</span>(things_with_io)?;</code></pre></div>
</section><section id="unsafe-sublanguage" class="slide level2">
<h2>Unsafe sublanguage</h2>
<ul>
<li>Some things are impossible in safe rust</li>
<li>Writing many datastructures included</li>
<li>&quot;unsafe&quot; allows circumvention of rules</li>
<li>Change mutability of a type</li>
<li>Access global shared state</li>
<li>Dereference raw pointers</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>allow<span class="at">(</span>mutable_transmutes<span class="at">)]</span> <span class="co">// This is always a bad idea!</span>
<span class="kw">fn</span> fun(t: &amp;Thing) <span class="op">{</span>
    <span class="kw">let</span> t2: &amp;<span class="kw">mut</span> Thing = <span class="kw">unsafe</span> <span class="op">{</span> std::mem::transmute(t) <span class="op">}</span>;
<span class="op">}</span></code></pre></div>
</section><section id="foreign-function-interfaces" class="slide level2">
<h2>Foreign Function Interfaces</h2>
<ul>
<li>Rust ABI is unstable</li>
<li>Interfacing with foreign code is done via &quot;C&quot; (platform) ABI</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::ffi::<span class="op">{</span><span class="dt">c_void</span>, <span class="dt">c_uint</span><span class="op">}</span>;

<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> <span class="kw">fn</span> call_this_from_c(raw: *cost <span class="dt">c_void</span>) <span class="op">{</span>
    <span class="co">// ...</span>
<span class="op">}</span>

<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> <span class="op">{</span>
    <span class="kw">fn</span> call_this_from_rust(num: <span class="dt">c_uint</span>);
<span class="op">}</span>

<span class="kw">unsafe</span> <span class="op">{</span> call_this_from_rust(<span class="dv">42</span>) <span class="op">}</span>;</code></pre></div>
</section><section id="declarative-macros" class="slide level2">
<h2>Declarative Macros</h2>
<ul>
<li>Opererate on a given AST</li>
<li>Always expand to valid code</li>
<li>Hygenic and pure</li>
</ul>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">macro_rules!</span> vec <span class="op">{</span>
    ( $( $x:expr ),* ) =&gt; <span class="op">{</span>
        <span class="op">{</span>
            <span class="kw">let</span> <span class="kw">mut</span> temp_vec = <span class="dt">Vec</span>::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        <span class="op">}</span>
    <span class="op">}</span>;
<span class="op">}</span></code></pre></div>
</section><section id="procedural-macros" class="slide level2">
<h2>Procedural Macros</h2>
<ul>
<li>Second type of macros that run inside the compiler</li>
<li>Execute code to generate code at compile-time</li>
<li>Example: <code>&quot;#[derive(Clone)]&quot;</code></li>
<li>You can do cool things with this!</li>
</ul>
<p>Shameless plug: <a href="https://github.com/rust-cli/thunder">thunder.rs</a></p>
</section></section>
<section><section id="questions" class="titleslide slide level1"><h1>Questions? üòÖ</h1></section><section id="katharina-fey" class="slide level2">
<h2>Katharina Fey</h2>
<ul>
<li>Works at <a href="https://ferrous-systems.com">Ferrous Systems</a></li>
<li>Get in touch: <a href="mailto:kookie@spacekookie.de">kookie@spacekookie.de</a></li>
<li>Twitter: <a href="https://twitter.com/spacekookie">@spacekookie</a></li>
<li>GPG: 555F 2E4B 6F87 F91A 4110</li>
</ul>
</section></section>
    </div>
  </div>

  <script src="template/lib/js/head.min.js"></script>
  <script src="template/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display a presentation progress bar
        progress: true,
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'template/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'template/plugin/zoom-js/zoom.js', async: true },
              { src: 'template/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
